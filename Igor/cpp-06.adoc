<<<<<<< HEAD
= BilgisayarlÄ± GÃ¶rÃ¼ ve GÃ¶rÃ¼ntÃ¼ Ä°ÅŸleme iÃ§in Modern C ++
:TOC:

== 1. Ã–ZET

Bu seride 

* Statik deÄŸiÅŸkenler ve yÃ¶ntemler ana hatlarÄ±yla(Outline Static variables and methods )
* HafÄ±zadaki sayÄ±larÄ±n temsili(Representation of numbers in memory )
* Ham C dizileri(Raw C arrays )
* {cpp}'da sahip olmayan iÅŸaretÃ§iler(Non-owning pointers in C++)
* HafÄ±zadaki sÄ±nÄ±flar(Classes in memory)

Ã¶rneklerle anlatÄ±lmaktadÄ±r.

== 2. Statik deÄŸiÅŸkenler ve yÃ¶ntemler
* Bir sÄ±nÄ±fÄ±n statik Ã¼ye deÄŸiÅŸkenleri
** Nesne baÅŸÄ±na deÄŸil, sÄ±nÄ±f baÅŸÄ±na tam olarak bir kez bulunur
** DeÄŸer, tÃ¼m Ã¶rneklerde eÅŸittir
** *.cpp dosyalarÄ±nda tanÄ±mlanmalÄ±dÄ±r
* Bir sÄ±nÄ±fÄ±n statik Ã¼ye fonksiyonlarÄ±
** Bir sÄ±nÄ±fÄ±n nesnesine sahip deÄŸilsiniz
** private Ã¼yelere eriÅŸebilir ancak bir nesneye ihtiyaÃ§ duyar
** Arama iÃ§in sÃ¶zdizimi:(Syntax for calling):
*ClassName::MethodName(<params>)*

=== 2.1. Statik deÄŸiÅŸkenler(Static variables)

[source, cpp]
----
 #include <iostream>
 using std :: cout; using std :: endl;
 struct Counted {
 Counted () { Counted :: count ++; }
 ~Counted () { Counted ::count --; }
 static int count; // Static counter member.
 };
 int Counted :: count = 0; // Definition.
 int main () {
 Counted a, b;
 cout << "Count: " << Counted :: count << endl;
 Counted c;
 cout << "Count: " << Counted :: count << endl;
 return 0;
 }
----

=== 2.2. Statik Ã¼ye fonksiyonlarÄ±(Static member functions)

[source, cpp]
----
 #include <math.h>
 #include <iostream>
 using std :: cout; using std :: endl;
 class Point {
 public:
 Point(int x, int y) : x_(x), y_(y) {}
 static float dist(const Point& a, const Point& b) {
 int diff_x = a.x_ - b.x_;
 int diff_y = a.y_ - b.y_;
 return sqrt(diff_x * diff_x + diff_y * diff_y);
 }
 private:
 int x_ = 0; int y_ = 0;
 };
 int main () {
 Point a(2, 2), b(1, 1);
 cout << "Dist is " << Point :: dist(a, b) << endl;
 return 0;
 }
----

== 3. DeÄŸiÅŸken bildirimini geri Ã§aÄŸÄ±rma

[source, cpp]
----
int x = 1;
float y = 1.1313f;
----
[TIP]
====
HafÄ±zada sayÄ± nasÄ±l temsil edilir?
====
image::images/memory.png[]
[TIP]
====
Bir tÃ¼r ne kadar belleÄŸe ihtiyaÃ§ duyar?
====

* Bir tÃ¼r iÃ§in bayt sayÄ±sÄ±nÄ± alÄ±n:
*sizeof(<type>)*

image::type.png[]

=== 3.1. sizeof() Ã–rneÄŸi

[source, cpp]
----
 // machine specific type sizes
 sizeof(bool) == 1 byte;
 sizeof(char) == 1 byte;
 // floating point types
 sizeof(float) == 4 bytes;
 sizeof(double) == 8 bytes;
 sizeof(long double) == 16 bytes;
 // integral data types
 sizeof(short int) == 2 bytes;
 sizeof(unsigned short int) == 2 bytes;
 sizeof(int) == 4 bytes;
 sizeof(unsigned int) == 4 bytes;
 sizeof(long int) == 8 bytes;
 sizeof(unsigned long int) == 8 bytes;
----

=== 3.2. Tam sayÄ± tÃ¼rlerini temsil etme

[source, cpp]
----
 #include <iostream>
 using std :: cout;
 int main () {
 unsigned short int k = 37;
 cout << "sizeof(" << k << ") is " << sizeof(k)
 << " bytes or " << sizeof(k) * 8 << " bits.";
 }
----

[source, cpp]
----
sizeof(37) is 2 bytes or 16 bit
----

==== HafÄ±zada temsil:

image::images/byte.png[]

*37=0â‹…2^15^+ â‹¯ + 1â‹…2^5^+0â‹…2^4^+0â‹…2^3^+1â‹…2^2^+0â‹…2^1^+1â‹…2^0^*

=== 3.3. Temsil edilebilir aralÄ±klar

* 2 Byte

** short int  ->     [-2^15^, +2^15^)
** unsigned short int   ->  [0, +2^16^)

* 4 Byte
** int  ->  [-2^31^, +2^31^)
** unsigned int  ->  [0, +2^32^)

* 8 Byte
** long int  ->  [-2^63^, +2^63^)
** unsigned long int  ->  [0, +2^64^)

== 4. Floating point numbers(Kayan nokta sayÄ±larÄ±)

[source, C++]
----
 #include <iostream>
 using std :: cout;
 int main( int argc , char *argv [] ) {
 float k = 3.14159;
 cout << "sizeof(" << k << ") is " << sizeof(k)
 << " bytes or " << sizeof(k) * 8 << " bits.";
 }
----

==== Output:

[source, C++]
----
sizeof (3.141590) is 4 bytes or 32 bit
----

=== 4.1. HafÄ±zada temsil

image::images/floating.png[]

* Bellekte:
** Ä°ÅŸaret(Sign) ğ‘  = 0
** Ãœs(Exponent) ğ‘’ = 1â‹…2^7^+ 0â‹…2^6^+ â‹¯ + 0â‹…2^0^âˆ’127 = 1
** Mantis(Mantissa) ğ‘š = 
** SayÄ±(Number) ğ‘˜ = âˆ’1^ğ‘ ^â‹… 2^ğ‘’^â‹…__ m__
* Temsil edilebilir aralÄ±k:
** binary: Â±[1.7 â‹… 2âˆ’^126^, 2.2 â‹… 2^127^]
** decimal: Â±[1.2 â‹… 10^âˆ’38^, 3.4 â‹… 10^38^]

=== 4.2. float vs. double

* Float ile aynÄ± temsil
* Double float iÃ§in 4 yerine 8 bayt alÄ±r
* Daha Uzun Ãœs ve Mantissa.
* Ãœs = float iÃ§in 8 yerine 11 Bit
* Mantissa = float iÃ§in 23 yerine 53 Bit

=== 4.3. Neyi temsil edebiliriz?


[width="100%"]
|====================
|VeriTipi(Datatype)|Bellek(Memory)|AralÄ±ÄŸÄ±(Interval)
| int   | 4 Byte |  [0, 4.3 â‹… 10^9^)
|float|4 Byte|[1.18â‹…10âˆ’^38^,3.4â‹…10^38^] 
|====================

* *int:* Her sayÄ± | ğ‘¥ | âˆˆ [0, 2^32^) 1'lik artÄ±ÅŸlarla gÃ¶sterilebilir 
* *float:* artÄ±ÅŸ, Ãœs'Ã¼n bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne baÄŸlÄ±dÄ±r!
** Ãœs: GÃ¶sterilebilir aralÄ±ÄŸÄ±n boyutunu tanÄ±mlar, 
*8 Bit â†’ [2^âˆ’126^, 2^127^] = [1.2 â‹… 10^âˆ’38^, 1.7 â‹… 10^38^]*
** Mantis: 8 anlamlÄ± basamaklÄ±, 23 Bit uzunluÄŸunda bir sabit oluÅŸturur

=== 4.4. SÄ±nÄ±rlÄ± sayÄ±da anlamlÄ± basamak
image::images/addition.png[]

*BasamaklarÄ±n yok olmasÄ±*

[source,C++]
----
 #include <cmath>
 #include <iostream>
 using std :: cout; using std :: endl;
 int main () {
 float pi = M_PI;
 float big_number = 1e7;
 cout << "Pi before: " << pi << endl;
 pi += big_number ;
 pi -= big_number ;
 cout << "Pi after: " << pi << endl;
 cout << "Difference: " << M_PI - pi << endl;
 return 0;
 }
----

==== sonuÃ§
[source,C++]
----
Pi before: 3.14159
Pi after: 3
Difference: 0.141593
----

== 5. C tarzÄ± diziler

* std::array, std::vector, std::string
* Dizinin uzunluÄŸu sabittir
* Endeksleme 0 ile baÅŸlar!
* Bir dizinin Ã¶ÄŸeleri sÃ¼rekli bellekte bulunur.

==== Bildirme(Declaration):

[source, cpp]
----
Type array_name[length];
Type array_name[length] = {n0, n1, n2, ..., nX};
Type array_name[] = { n1, n2, n3};
----

=== 5.1. Diziler basit veri taÅŸÄ±yÄ±cÄ±larÄ±dÄ±r

[source, cpp]
----
 int main () {
 int shorts [5] = {5, 4, 3, 2, 1};
 double doubles [10];
 char chars [] = {'h', 'a', 'l', 'l', 'o'};
 shorts [3] = 4;
 chars [1] = 'e';
 chars [4] = chars [2];
 doubles [1] = 3.2;
 }
----

=== 5.2. Diziler ve sizeof ()

* sizeof() of an array is sizeof(<type>) * <array_length>

[source, cpp]
----
 int shortA [5] = {5, 4, 3, 2, 1};
 double longA [4] = {1.0 , 1.1, 1.2, 1.3};
 sizeof(shortA) = 20
 sizeof(shortA) / sizeof(shortA [0]) = 5
 sizeof(longA) = 32
 sizeof(longA) / sizeof(longA [0]) = 4
----

== 6. Ã‡alÄ±ÅŸma belleÄŸi veya RAM

.http://www.clipartsuggest.com/
image::images/ram.png[]

* Ã‡alÄ±ÅŸma belleÄŸi doÄŸrusal adreslemeye sahiptir
* Her baytÄ±n, genellikle onaltÄ±lÄ±k biÃ§imde sunulan bir adresi vardÄ±r, Ã¶r. 0x7fffb7335fdc
* Herhangi bir adrese rastgele eriÅŸilebilir
* Ä°ÅŸaretÃ§i, bellek adreslerini depolamak iÃ§in bir tÃ¼rdÃ¼r


== 7. Pointer

* Pointer tipleri *<TYPE>** ÅŸeklinde tanÄ±mlanÄ±r.
* Ä°ÅŸaretÃ§ilerin bir tÃ¼rÃ¼ var
* Ä°ÅŸaretÃ§i *<TYPE>**  yalnÄ±zca <TYPE> tÃ¼rÃ¼nde bir deÄŸiÅŸkene iÅŸaret edebilir
* BaÅŸlatÄ±lmamÄ±ÅŸ iÅŸaretÃ§iler rastgele bir adresi iÅŸaret eder
* Ä°ÅŸaretÃ§ileri her zaman bir adrese veya nullptr'e ile baÅŸlatÄ±n

==== Example:

[source,cpp]
1 int* a = nullptr;
2 double* b = nullptr;
3 YourType* c = nullptr;

=== 7.1. Sahip olmayan iÅŸaretÃ§iler(Non-owning pointers)

* Ä°ÅŸlenmemiÅŸ bir iÅŸaretÃ§i tarafÄ±ndan iÅŸaret edilen bellek, iÅŸaretÃ§i kapsam dÄ±ÅŸÄ±na Ã§Ä±ktÄ±ÄŸÄ±nda kaldÄ±rÄ±lmÄ±yor
* Ä°ÅŸaretÃ§iler hafÄ±zaya sahip olabilir veya olmayabilir
* BelleÄŸe sahip olmak, temizlenmesinden sorumlu olmak demektir
* Ham iÅŸaretÃ§iler asla hafÄ±zaya sahip olmamalÄ±dÄ±r(Raw pointers should never own
memory)
* Daha sonra hafÄ±zaya sahip olan akÄ±llÄ± iÅŸaretÃ§ilerden(smart pointers) bahsedeceÄŸiz

=== 7.2. Ä°ÅŸaretÃ§iler iÃ§in adres operatÃ¶rÃ¼

* OperatÃ¶r & bellekteki deÄŸiÅŸkenin adresini dÃ¶ndÃ¼rÃ¼r
* DÃ¶nÃ¼ÅŸ deÄŸeri tÃ¼rÃ¼ 'deÄŸer tÃ¼rÃ¼ne iÅŸaretÃ§i' dir

==== Example:

[source,cpp]
 int a = 42;
 int* a_ptr = &a;
 
image::images/p1.png[]

=== 7.3. Pointer to pointer

==== Example:

[source,cpp]
 int a = 42;
 int* a_ptr = &a;
 int** a_ptr_ptr = &a_ptr;
 
image::images/p2.png[]

=== 7.4. Ä°ÅŸaretÃ§i referans alma

* OperatÃ¶r *, iÅŸaretÃ§inin iÅŸaret ettiÄŸi deÄŸiÅŸkenin deÄŸerini verir
* Nullptr'nin referansÄ±nÄ±n kaldÄ±rÄ±lmasÄ±: Segmentasyon HatasÄ±(Segmentation Fault)
* BirimselleÅŸtirilmiÅŸ gÃ¶stericinin referansÄ±nÄ±n kaldÄ±rÄ±lmasÄ±: TanÄ±msÄ±z DavranÄ±ÅŸ(Undefined Behavior)

[source,cpp]
----
 #include <iostream>
 using std :: cout; using std :: endl;
 int main () {
 int a = 42;
 int* a_ptr = &a;
 int b = *a_ptr;
 cout << "a = " << a << " b = " << b << endl;
 *a_ptr = 13;
 cout << "a = " << a << " b = " << b << endl;
 return 0;
 }
----

==== Output:

[source, cpp]
 a = 42, b = 42
 a = 13, b = 42
 
=== 7.5. BaÅŸlatÄ±lmamÄ±ÅŸ iÅŸaretÃ§i

[source,cpp]
----
 #include <iostream>
 using std :: cout;
 using std :: endl;
 int main () {
 int* i_ptr; // BAD! Never leave unitialized!
 cout << "ptr address: " << i_ptr << endl;
 cout << "value under ptr: " << *i_ptr << endl;
 i_ptr = nullptr;
 cout << "new ptr address: " << i_ptr << endl;
 cout << "ptr size: " << sizeof(i_ptr) << " bytes";
 cout << " (" << sizeof(i_ptr) * 8 << "bit) " << endl;
 return 0;
 }
----

----
1 ptr address: 0x400830
2 value under ptr: -1991643855
3 new ptr address: 0
4 ptr size: 8 bytes (64 bit)
----
[IMPORTANT]
====
* Her zaman bir deÄŸer veya nullptr ile baÅŸlat
* Bir nullptr baÅŸvurusunun kaldÄ±rÄ±lmasÄ± Segmentasyon HatasÄ±na neden olur
* Segmentasyon HatalarÄ±nÄ± Ã¶nlemek iÃ§in *if* kullanÄ±n

[source,cpp]
----
 if(some_ptr ) {
 // only enters if some_ptr != nullptr
 }
 if(! some_ptr) {
 // only enters if some_ptr == nullptr
 }
----
====

== 8. Bellekteki diziler ve iÅŸaretÃ§iler

image::images/p3.png[]

* Dizi Ã¶ÄŸeleri bellekte sÃ¼reklidir
* Bir dizinin adÄ±, bir gÃ¶stericinin takma adÄ±dÄ±r:

[source,cpp]
 double ar [3];
 double* ar_ptr = ar;
 double* ar_ptr = &ar [0];

* *[]* OperatÃ¶rÃ¼yle dizi Ã¶ÄŸelerini alÄ±n

[CAUTION]
====
*Dikkatli! TaÅŸma!*

[source,cpp]
----
 #include <iostream>
 int main () {
 int ar[] = {1, 2, 3};
 // WARNING! Iterating too far!
 for (int i = 0; i < 6; i++){
 std :: cout << i << ": value: " << ar[i]
 << "\t addr:" << &ar[i] << std :: endl;
 }
 return 0;
 }
----

----
 0: value: 1 addr :0 x7ffd17deb4e0
 1: value: 2 addr :0 x7ffd17deb4e4
 2: value: 3 addr :0 x7ffd17deb4e8
 3: value: 0 addr :0 x7ffd17deb4ec
 4: value: 4196992 addr :0 x7ffd17deb4f0
 5: value: 32764 addr :0 x7ffd17deb4f4
----
====

=== 8.1. Bellekteki Ã¶zel nesneler

* Bir nesnenin parÃ§alarÄ±nÄ±n bellekte nasÄ±l saklandÄ±ÄŸÄ± tam olarak tanÄ±mlanmamÄ±ÅŸtÄ±r
* Genellikle sÄ±rayla
* Derleyici belleÄŸi optimize edebilir

[source,cpp]
----
 class MemoryTester {
 public:
 int i;
 double d;
 void SetData(float data) { data_ = data; }
 float* GetDataAddress () { return &data_; }
 private:
 float data_; // position of types is important
 };
----

==== Ne nerede?

[source,cpp]
----
 #include "class_memory.h"
 #include <iostream >
 using std :: cout; using std :: endl;
 int main () {
 MemoryTester tester;
 tester.i = 1; tester.d = 2; tester.SetData (3);
 cout << "Sizeof tester: " << sizeof(tester) << endl;
 cout << "Address of i: " << &tester.i << endl;
 cout << "Address of d: " << &tester.d << endl;
 cout << "Address of _data: "
 << tester. GetDataAddress () << endl;
 return 0;
 }
----

----
// memory: |i|i|i|i|_|_|_|_|d|d|d|d|d|d|d|d|...
// who is who: | int i |padding| double d |...
----

== Referanslar

=======
= BilgisayarlÄ± GÃ¶rÃ¼ ve GÃ¶rÃ¼ntÃ¼ Ä°ÅŸleme iÃ§in Modern C ++
:TOC:

== 1. Ã–ZET

Bu seride 

* Statik deÄŸiÅŸkenler ve yÃ¶ntemler ana hatlarÄ±yla(Outline Static variables and methods )
* HafÄ±zadaki sayÄ±larÄ±n temsili(Representation of numbers in memory )
* Ham C dizileri(Raw C arrays )
* {cpp}'da sahip olmayan iÅŸaretÃ§iler(Non-owning pointers in C++)
* HafÄ±zadaki sÄ±nÄ±flar(Classes in memory)

Ã¶rneklerle anlatÄ±lmaktadÄ±r.

== 2. Statik deÄŸiÅŸkenler ve yÃ¶ntemler
* Bir sÄ±nÄ±fÄ±n statik Ã¼ye deÄŸiÅŸkenleri
** Nesne baÅŸÄ±na deÄŸil, sÄ±nÄ±f baÅŸÄ±na tam olarak bir kez bulunur
** DeÄŸer, tÃ¼m Ã¶rneklerde eÅŸittir
** *.cpp dosyalarÄ±nda tanÄ±mlanmalÄ±dÄ±r
* Bir sÄ±nÄ±fÄ±n statik Ã¼ye fonksiyonlarÄ±
** Bir sÄ±nÄ±fÄ±n nesnesine sahip deÄŸilsiniz
** private Ã¼yelere eriÅŸebilir ancak bir nesneye ihtiyaÃ§ duyar
** Arama iÃ§in sÃ¶zdizimi:(Syntax for calling):
*ClassName::MethodName(<params>)*

=== 2.1. Statik deÄŸiÅŸkenler(Static variables)

[source, cpp]
----
 #include <iostream>
 using std :: cout; using std :: endl;
 struct Counted {
 Counted () { Counted :: count ++; }
 ~Counted () { Counted ::count --; }
 static int count; // Static counter member.
 };
 int Counted :: count = 0; // Definition.
 int main () {
 Counted a, b;
 cout << "Count: " << Counted :: count << endl;
 Counted c;
 cout << "Count: " << Counted :: count << endl;
 return 0;
 }
----

=== 2.2. Statik Ã¼ye fonksiyonlarÄ±(Static member functions)

[source, cpp]
----
 #include <math.h>
 #include <iostream>
 using std :: cout; using std :: endl;
 class Point {
 public:
 Point(int x, int y) : x_(x), y_(y) {}
 static float dist(const Point& a, const Point& b) {
 int diff_x = a.x_ - b.x_;
 int diff_y = a.y_ - b.y_;
 return sqrt(diff_x * diff_x + diff_y * diff_y);
 }
 private:
 int x_ = 0; int y_ = 0;
 };
 int main () {
 Point a(2, 2), b(1, 1);
 cout << "Dist is " << Point :: dist(a, b) << endl;
 return 0;
 }
----

== 3. DeÄŸiÅŸken bildirimini geri Ã§aÄŸÄ±rma

[source, cpp]
----
int x = 1;
float y = 1.1313f;
----
[TIP]
====
HafÄ±zada sayÄ± nasÄ±l temsil edilir?
====
image::images/memory.png[]
[TIP]
====
Bir tÃ¼r ne kadar belleÄŸe ihtiyaÃ§ duyar?
====

* Bir tÃ¼r iÃ§in bayt sayÄ±sÄ±nÄ± alÄ±n:
*sizeof(<type>)*

image::type.png[]

=== 3.1. sizeof() Ã–rneÄŸi

[source, cpp]
----
 // machine specific type sizes
 sizeof(bool) == 1 byte;
 sizeof(char) == 1 byte;
 // floating point types
 sizeof(float) == 4 bytes;
 sizeof(double) == 8 bytes;
 sizeof(long double) == 16 bytes;
 // integral data types
 sizeof(short int) == 2 bytes;
 sizeof(unsigned short int) == 2 bytes;
 sizeof(int) == 4 bytes;
 sizeof(unsigned int) == 4 bytes;
 sizeof(long int) == 8 bytes;
 sizeof(unsigned long int) == 8 bytes;
----

=== 3.2. Tam sayÄ± tÃ¼rlerini temsil etme

[source, cpp]
----
 #include <iostream>
 using std :: cout;
 int main () {
 unsigned short int k = 37;
 cout << "sizeof(" << k << ") is " << sizeof(k)
 << " bytes or " << sizeof(k) * 8 << " bits.";
 }
----

[source, cpp]
----
sizeof(37) is 2 bytes or 16 bit
----

==== HafÄ±zada temsil:

image::images/byte.png[]

*37=0â‹…2^15^+ â‹¯ + 1â‹…2^5^+0â‹…2^4^+0â‹…2^3^+1â‹…2^2^+0â‹…2^1^+1â‹…2^0^*

=== 3.3. Temsil edilebilir aralÄ±klar

* 2 Byte

** short int  ->     [-2^15^, +2^15^)
** unsigned short int   ->  [0, +2^16^)

* 4 Byte
** int  ->  [-2^31^, +2^31^)
** unsigned int  ->  [0, +2^32^)

* 8 Byte
** long int  ->  [-2^63^, +2^63^)
** unsigned long int  ->  [0, +2^64^)

== 4. Floating point numbers(Kayan nokta sayÄ±larÄ±)

[source, C++]
----
 #include <iostream>
 using std :: cout;
 int main( int argc , char *argv [] ) {
 float k = 3.14159;
 cout << "sizeof(" << k << ") is " << sizeof(k)
 << " bytes or " << sizeof(k) * 8 << " bits.";
 }
----

==== Output:

[source, C++]
----
sizeof (3.141590) is 4 bytes or 32 bit
----

=== 4.1. HafÄ±zada temsil

image::images/floating.png[]

* Bellekte:
** Ä°ÅŸaret(Sign) ğ‘  = 0
** Ãœs(Exponent) ğ‘’ = 1â‹…2^7^+ 0â‹…2^6^+ â‹¯ + 0â‹…2^0^âˆ’127 = 1
** Mantis(Mantissa) ğ‘š = 
** SayÄ±(Number) ğ‘˜ = âˆ’1^ğ‘ ^â‹… 2^ğ‘’^â‹…__ m__
* Temsil edilebilir aralÄ±k:
** binary: Â±[1.7 â‹… 2âˆ’^126^, 2.2 â‹… 2^127^]
** decimal: Â±[1.2 â‹… 10^âˆ’38^, 3.4 â‹… 10^38^]

=== 4.2. float vs. double

* Float ile aynÄ± temsil
* Double float iÃ§in 4 yerine 8 bayt alÄ±r
* Daha Uzun Ãœs ve Mantissa.
* Ãœs = float iÃ§in 8 yerine 11 Bit
* Mantissa = float iÃ§in 23 yerine 53 Bit

=== 4.3. Neyi temsil edebiliriz?


[width="100%"]
|====================
|VeriTipi(Datatype)|Bellek(Memory)|AralÄ±ÄŸÄ±(Interval)
| int   | 4 Byte |  [0, 4.3 â‹… 10^9^)
|float|4 Byte|[1.18â‹…10âˆ’^38^,3.4â‹…10^38^] 
|====================

* *int:* Her sayÄ± | ğ‘¥ | âˆˆ [0, 2^32^) 1'lik artÄ±ÅŸlarla gÃ¶sterilebilir 
* *float:* artÄ±ÅŸ, Ãœs'Ã¼n bÃ¼yÃ¼klÃ¼ÄŸÃ¼ne baÄŸlÄ±dÄ±r!
** Ãœs: GÃ¶sterilebilir aralÄ±ÄŸÄ±n boyutunu tanÄ±mlar, 
*8 Bit â†’ [2^âˆ’126^, 2^127^] = [1.2 â‹… 10^âˆ’38^, 1.7 â‹… 10^38^]*
** Mantis: 8 anlamlÄ± basamaklÄ±, 23 Bit uzunluÄŸunda bir sabit oluÅŸturur

=== 4.4. SÄ±nÄ±rlÄ± sayÄ±da anlamlÄ± basamak
image::images/addition.png[]

*BasamaklarÄ±n yok olmasÄ±*

[source,C++]
----
 #include <cmath>
 #include <iostream>
 using std :: cout; using std :: endl;
 int main () {
 float pi = M_PI;
 float big_number = 1e7;
 cout << "Pi before: " << pi << endl;
 pi += big_number ;
 pi -= big_number ;
 cout << "Pi after: " << pi << endl;
 cout << "Difference: " << M_PI - pi << endl;
 return 0;
 }
----

==== sonuÃ§
[source,C++]
----
Pi before: 3.14159
Pi after: 3
Difference: 0.141593
----

== 5. C tarzÄ± diziler

* std::array, std::vector, std::string
* Dizinin uzunluÄŸu sabittir
* Endeksleme 0 ile baÅŸlar!
* Bir dizinin Ã¶ÄŸeleri sÃ¼rekli bellekte bulunur.

==== Bildirme(Declaration):

[source, cpp]
----
Type array_name[length];
Type array_name[length] = {n0, n1, n2, ..., nX};
Type array_name[] = { n1, n2, n3};
----

=== 5.1. Diziler basit veri taÅŸÄ±yÄ±cÄ±larÄ±dÄ±r

[source, cpp]
----
 int main () {
 int shorts [5] = {5, 4, 3, 2, 1};
 double doubles [10];
 char chars [] = {'h', 'a', 'l', 'l', 'o'};
 shorts [3] = 4;
 chars [1] = 'e';
 chars [4] = chars [2];
 doubles [1] = 3.2;
 }
----

=== 5.2. Diziler ve sizeof ()

* sizeof() of an array is sizeof(<type>) * <array_length>

[source, cpp]
----
 int shortA [5] = {5, 4, 3, 2, 1};
 double longA [4] = {1.0 , 1.1, 1.2, 1.3};
 sizeof(shortA) = 20
 sizeof(shortA) / sizeof(shortA [0]) = 5
 sizeof(longA) = 32
 sizeof(longA) / sizeof(longA [0]) = 4
----

== 6. Ã‡alÄ±ÅŸma belleÄŸi veya RAM

.http://www.clipartsuggest.com/
image::images/ram.png[]

* Ã‡alÄ±ÅŸma belleÄŸi doÄŸrusal adreslemeye sahiptir
* Her baytÄ±n, genellikle onaltÄ±lÄ±k biÃ§imde sunulan bir adresi vardÄ±r, Ã¶r. 0x7fffb7335fdc
* Herhangi bir adrese rastgele eriÅŸilebilir
* Ä°ÅŸaretÃ§i, bellek adreslerini depolamak iÃ§in bir tÃ¼rdÃ¼r


== 7. Pointer

* Pointer tipleri *<TYPE>** ÅŸeklinde tanÄ±mlanÄ±r.
* Ä°ÅŸaretÃ§ilerin bir tÃ¼rÃ¼ var
* Ä°ÅŸaretÃ§i *<TYPE>**  yalnÄ±zca <TYPE> tÃ¼rÃ¼nde bir deÄŸiÅŸkene iÅŸaret edebilir
* BaÅŸlatÄ±lmamÄ±ÅŸ iÅŸaretÃ§iler rastgele bir adresi iÅŸaret eder
* Ä°ÅŸaretÃ§ileri her zaman bir adrese veya nullptr'e ile baÅŸlatÄ±n

==== Example:

[source,cpp]
1 int* a = nullptr;
2 double* b = nullptr;
3 YourType* c = nullptr;

=== 7.1. Sahip olmayan iÅŸaretÃ§iler(Non-owning pointers)

* Ä°ÅŸlenmemiÅŸ bir iÅŸaretÃ§i tarafÄ±ndan iÅŸaret edilen bellek, iÅŸaretÃ§i kapsam dÄ±ÅŸÄ±na Ã§Ä±ktÄ±ÄŸÄ±nda kaldÄ±rÄ±lmÄ±yor
* Ä°ÅŸaretÃ§iler hafÄ±zaya sahip olabilir veya olmayabilir
* BelleÄŸe sahip olmak, temizlenmesinden sorumlu olmak demektir
* Ham iÅŸaretÃ§iler asla hafÄ±zaya sahip olmamalÄ±dÄ±r(Raw pointers should never own
memory)
* Daha sonra hafÄ±zaya sahip olan akÄ±llÄ± iÅŸaretÃ§ilerden(smart pointers) bahsedeceÄŸiz

=== 7.2. Ä°ÅŸaretÃ§iler iÃ§in adres operatÃ¶rÃ¼

* OperatÃ¶r & bellekteki deÄŸiÅŸkenin adresini dÃ¶ndÃ¼rÃ¼r
* DÃ¶nÃ¼ÅŸ deÄŸeri tÃ¼rÃ¼ 'deÄŸer tÃ¼rÃ¼ne iÅŸaretÃ§i' dir

==== Example:

[source,cpp]
 int a = 42;
 int* a_ptr = &a;
 
image::images/p1.png[]

=== 7.3. Pointer to pointer

==== Example:

[source,cpp]
 int a = 42;
 int* a_ptr = &a;
 int** a_ptr_ptr = &a_ptr;
 
image::images/p2.png[]

=== 7.4. Ä°ÅŸaretÃ§i referans alma

* OperatÃ¶r *, iÅŸaretÃ§inin iÅŸaret ettiÄŸi deÄŸiÅŸkenin deÄŸerini verir
* Nullptr'nin referansÄ±nÄ±n kaldÄ±rÄ±lmasÄ±: Segmentasyon HatasÄ±(Segmentation Fault)
* BirimselleÅŸtirilmiÅŸ gÃ¶stericinin referansÄ±nÄ±n kaldÄ±rÄ±lmasÄ±: TanÄ±msÄ±z DavranÄ±ÅŸ(Undefined Behavior)

[source,cpp]
----
 #include <iostream>
 using std :: cout; using std :: endl;
 int main () {
 int a = 42;
 int* a_ptr = &a;
 int b = *a_ptr;
 cout << "a = " << a << " b = " << b << endl;
 *a_ptr = 13;
 cout << "a = " << a << " b = " << b << endl;
 return 0;
 }
----

==== Output:

[source, cpp]
 a = 42, b = 42
 a = 13, b = 42
 
=== 7.5. BaÅŸlatÄ±lmamÄ±ÅŸ iÅŸaretÃ§i

[source,cpp]
----
 #include <iostream>
 using std :: cout;
 using std :: endl;
 int main () {
 int* i_ptr; // BAD! Never leave unitialized!
 cout << "ptr address: " << i_ptr << endl;
 cout << "value under ptr: " << *i_ptr << endl;
 i_ptr = nullptr;
 cout << "new ptr address: " << i_ptr << endl;
 cout << "ptr size: " << sizeof(i_ptr) << " bytes";
 cout << " (" << sizeof(i_ptr) * 8 << "bit) " << endl;
 return 0;
 }
----

----
1 ptr address: 0x400830
2 value under ptr: -1991643855
3 new ptr address: 0
4 ptr size: 8 bytes (64 bit)
----
[IMPORTANT]
====
* Her zaman bir deÄŸer veya nullptr ile baÅŸlat
* Bir nullptr baÅŸvurusunun kaldÄ±rÄ±lmasÄ± Segmentasyon HatasÄ±na neden olur
* Segmentasyon HatalarÄ±nÄ± Ã¶nlemek iÃ§in *if* kullanÄ±n

[source,cpp]
----
 if(some_ptr ) {
 // only enters if some_ptr != nullptr
 }
 if(! some_ptr) {
 // only enters if some_ptr == nullptr
 }
----
====

== 8. Bellekteki diziler ve iÅŸaretÃ§iler

image::images/p3.png[]

* Dizi Ã¶ÄŸeleri bellekte sÃ¼reklidir
* Bir dizinin adÄ±, bir gÃ¶stericinin takma adÄ±dÄ±r:

[source,cpp]
 double ar [3];
 double* ar_ptr = ar;
 double* ar_ptr = &ar [0];

* *[]* OperatÃ¶rÃ¼yle dizi Ã¶ÄŸelerini alÄ±n

[CAUTION]
====
*Dikkatli! TaÅŸma!*

[source,cpp]
----
 #include <iostream>
 int main () {
 int ar[] = {1, 2, 3};
 // WARNING! Iterating too far!
 for (int i = 0; i < 6; i++){
 std :: cout << i << ": value: " << ar[i]
 << "\t addr:" << &ar[i] << std :: endl;
 }
 return 0;
 }
----

----
 0: value: 1 addr :0 x7ffd17deb4e0
 1: value: 2 addr :0 x7ffd17deb4e4
 2: value: 3 addr :0 x7ffd17deb4e8
 3: value: 0 addr :0 x7ffd17deb4ec
 4: value: 4196992 addr :0 x7ffd17deb4f0
 5: value: 32764 addr :0 x7ffd17deb4f4
----
====

=== 8.1. Bellekteki Ã¶zel nesneler

* Bir nesnenin parÃ§alarÄ±nÄ±n bellekte nasÄ±l saklandÄ±ÄŸÄ± tam olarak tanÄ±mlanmamÄ±ÅŸtÄ±r
* Genellikle sÄ±rayla
* Derleyici belleÄŸi optimize edebilir

[source,cpp]
----
 class MemoryTester {
 public:
 int i;
 double d;
 void SetData(float data) { data_ = data; }
 float* GetDataAddress () { return &data_; }
 private:
 float data_; // position of types is important
 };
----

==== Ne nerede?

[source,cpp]
----
 #include "class_memory.h"
 #include <iostream >
 using std :: cout; using std :: endl;
 int main () {
 MemoryTester tester;
 tester.i = 1; tester.d = 2; tester.SetData (3);
 cout << "Sizeof tester: " << sizeof(tester) << endl;
 cout << "Address of i: " << &tester.i << endl;
 cout << "Address of d: " << &tester.d << endl;
 cout << "Address of _data: "
 << tester. GetDataAddress () << endl;
 return 0;
 }
----

----
// memory: |i|i|i|i|_|_|_|_|d|d|d|d|d|d|d|d|...
// who is who: | int i |padding| double d |...
----

== Referanslar

>>>>>>> fe3be6150d3b2a03dafcbde687e479d82fb25042
https://www.ipb.uni-bonn.de/wp-content/uploads/2018/05/lecture_6.pdf